25.10.17. FRI

-- ■ 데이터 정의 언어(Data Definition Language)
 -- ※ 데이터 정의 언어(DDL) 및 데이터 타입

   -- ο 데이터 타입 - 개요
      -- 데이터 타입 정보 확인
         SELECT DATA_TYPE, DATA_LENGTH, CHAR_LENGTH, CHAR_USED
         FROM USER_TAB_COLUMNS
         WHERE TABLE_NAME ='테이블명';


 -- ※ 테이블 생성 및 수정 삭제
   -- ο 테이블 생성 
     -------------------------------------------------------
     -- 기본 형식
     /*
         CREATE TABLE 테이블명
         (
              컬럼명  타입[(크기)]  [제약조건]
              ,컬럼명  타입[(크기)]  [제약조건]
          );
*/
          -- 테이블 생성
          -- 테이블명 : test
          -- 컬럼명 타입 폭 제약조건 NULL
          -- num   숫자 10 기본키  X
          -- name  문자 30        X
          -- birth 날짜 
          -- city  문자 30 
-- 날짜 폭지정 불가


          CREATE TABLE test (
  num NUMBER(10) PRIMARY KEY,
  name VARCHAR2(30) NOT NULL,
  birth DATE,
  city VARCHAR2(30)
);


            -- 저장된 객체의 정보는 DIC에 저장되며 값들은대문자로 저장됨
          -- 테이블의 목록 확인
          select*FROM tab;
          --컬럼 확인
          DESC test;
          SELECT*FROM cols WHERE table_name = 'TEST;
          SELECT*FROM col WHERE tname = 'TEST;

          --내용 확인
          SELECT*FROM test;



   -- ο 테이블 생성 - 가상 컬럼(virtual column)
     -------------------------------------------------------
     --값이 아닌 수식을 저장하는 컬럼
     --SYSDATE처럼 동적인 결과를 출력하는 함수는 저장 불가

     CREATE TABLE test(
        hak VARCHAR2(30) PRIMARY KEY
     ); --에러. test라는 객체 존재. 중복 작성 불가

     CREATE TABLE demo (
    hak VARCHAR2(30) PRIMARY KEY,
    name VARCHAR2(30) NOT NULL,
    kor NUMBER(3) NOT NULL,
    eng NUMBER(3) NOT NULL,
    mat NUMBER(3) NOT NULL,
    ave NUMBER(4,1) GENERATED ALWAYS AS ((kor + eng + mat) / 3) VIRTUAL
);


        --NOT NULL을 제외한 제약 조건은 복사되지 않는다.
        SELECT * FROM user_constraints WHERE table_name= 'EMP';
        --constraint_type : 제약조건
        -- p: 기본키, U 유니크, C NOT NULL등 CHECK 제약
        SELECT * FROM user_constraints WHERE table_name = 'EMP1';

    --TOT, AVE : 가상컬럼

    -- 가상컬럼은 insert,update로 값을 등록하거나 수정 불가





   -- ο 테이블 생성 - subquery를 이용한 테이블 생성 
     -------------------------------------------------------
     -- 기본형식
      CREATE  TABLE  테이블명 [(컬럼명, 컬럼명,...)] AS subquery;

        --존재하는 테이블을 이용하여 테이블 작성 : 구조 및 데이터 복사
        SELECT empNO,name,sal,bonus,sal+bonus FROM emp;

        CREATE TABLE emp1 AS
            select EMPnO,NAME,SAL,BONUS,SAL+BONUS pay ROM emp; --00998 컬럼명 규칙 위반

        SELECT * FROM emp;
        DESC emp;

        --컬럼명을 지정하여 구조 및 데이터 복사
        CREATE TABLE emp3(사번,이름,생년월일)AS
            SELECT empNo,name,TO_DATE(SUBSTR(rrn,1,6),'RRMMDD')
            FROM emp
            WHERE TO_DATE(SUBSTR(rrn,1,6),'RRMMDD')>='2000-01-01';

            SELECT*FROM tab;
            DESC emp3;

            SELECT * FROM emp3;

            -- emp 테이블의 테이블 구조만 복사 : NOT NULL 이외의 제약 조건은 복사되지 않음
            SELECT*FROM emp WHERE 1=0;

            CREATE TABLE emp3 AS 
                SELECT*FROM emp WHERE 1=0;

                SELECT*FROM tab;
                DESC emp3;

                select * FROM emp3;


            



   -- ο ALTER TABLE ~ ADD
     -------------------------------------------------------
     -- 기본형식
       ALTER TABLE 테이블명 ADD (컬럼명 자료형(크기));
       -- 기존 테이블에 새로운 컬럼 추가

       --test 테이블에 다음의 컬럼 추가
       --dept 문자 (30), sal 숫자(3) NOT NULL
       DESC test;

       ALTER TABLE test ADD (dept VARCHAR2(30),sal NUMBER(3) NOT NULL);
       DESC test;

       --emp2 테이블에 다음의 컬럼 추가
       --dept VARCHAR2(30) NOT NULL
       DESC emp2;

       ALTER TABLE emp2 ADD(dept VARCHAR2(30) NOT NULL);
       -- 에러 / 테이블에 데이터가 존재하면 NOTT NULL 속성의 컬럼을 추가할 수 없다.

       --dept VARCHAR2(30) 추가
       ALTER TABLE emp2 ADD (dept VARCHAR2(30));
       DESC emp2;

       --emp4 테이블 작성
       --emp 테이블에서 dept가 개발부인 사원만 다음의 컬럼과 값을 복사하여 emp4 테이블 작성
       --empNo,name,rrn,dept

        CREATE TABLE emp4(empNo,name,rrn,dept)AS
            SELECT empNo,name,rrn,dept
            FROM emp
            WHERE dept='개발부';

            SELECT * FROM emp4;

        --emp4 테이블에 다음의 컬럼 추가
        -- birth:rrn을 이용하여 생년월일 가상컬럼으로 추가

        ALTER TABLE emp4
        ADD (birth GENERATED ALWAYS AS (SUBSTR(rrn, 1, 6)) VIRTUAL);

        SELECT * FROM emp4;

   -- ο ALTER TABLE ~ MODIFY
     -------------------------------------------------------
     -- 기본형식
       ALTER TABLE 테이블명 MODIFY (컬럼명 자료형(크기));
        --컬럼의 타입, 크기 등을 변경

        DESC test;

        ALTER TABLE test MODIFY(sal NUMBEr(8));
        DESC test;
        desc emp2;

        ALTER TABLE emp2 MODIFY (name VARCHAR2)l
        ==에러 / 데이터가 존재하는 경우 길이는 데이터보다 크거나 같다




   -- ο ALTER TABLE ~ RENAME COLUMN
     -------------------------------------------------------
     -- 기본형식
       ALTER TABLE 테이블명 RENAME COLUMN 컬럼명 TO 새로운컬럼명
       -- 존재하는 컬럼의 이름을 변경

       DESC Emp;

       ALTTER 



   -- ο ALTER TABLE ~ DROP COLUMN
     -------------------------------------------------------
     -- 기본형식
      ALTER TABLE 테이블명 DROP COLUMN 컬럼명
    -컬럼 삭제 
  

   alter TABLE EMP2 DROP COLUMN 이름,
    SeLECt*grok EKP2[]



   -- ο ALTER TABLE ~ SET UNUSED -- 원FO대로 회복 불가
     -------------------------------------------------------
     
    alter table EMP1 set uunused(PAY)
    ES
    
    
    SELECT empNo, PAY fro< KV
   -- ο ALTER TABLE ~ SET UNUSED에 의해 논리적으로 삭제된 컬럼의 정보 확인
     -------------------------------------------------------
     --



   -- ο ALTER TABLE ~ DROP UNUSED COLUMNS
     -------------------------------------------------------
     --


   -- ο  테이블 삭제
     -------------------------------------------------------
     -- 기본형식
      DROP TABLE 테이블;  -- 휴지통에 임시보관
      DROP TABLE 테이블 PURGE;  -- 휴지통에 임시보관 하지 않고 바로 삭제
      DROP TABLE 테이블명 CASCADE CONSTRAINTS PURGE;
         -- 테이블과 그 테이블을 참조하는 FOREIGN K
     selecrT tABLE demo;
     SELECT * FROM EMP4; 
     SELECT * FROM EMP4;

     --원본 삭제 (복원불가
    DROP TABLE emp10 PURGE;

    SELECT * FROM tab;     

   -- ο RENAME
     -------------------------------------------------------
     -- 기본형식
       RENAME 옛이름 TO 새이름;

       --기본형식
      ghk  RENAME empt2 to demo;



   -- ο 휴지통(RECYCLEBIN) 정보 확인
    -- 삭제된 개체(objects)확인
     -------------------------------------------------------
     -
     SHOW RECYCLEBIN;
     SELECT * FROM RECYCLEBIN;
     --object_name,original_name


   -- ο FLASHBACK TABLE
     -------------------------------------------------------
     --DROP TABLE로 삭제된 테이블 복원
     
     --test 테이블 복원
     SELECT * FROM tab;

     FLASHBACK TABLE test TO BEFORE DROP;
     -- 동일한 original_name이 두 개 이상이면 마지막에 삭제된 테ㅣ블 복원
     SELECT * FROM tab;



    SELECT * FROM RECYCLEBIN;
    
    
    FLASHBACK TABLE "" To BEFORE DROP;

  SELECT * FROM "BIN$QmP77mCTRtyiBYrejaxxRg==$0";

  FLASHBACK TABLE "BIN$QmP77mCTRtyiBYrejaxxRg==$0" TO BEFORE DROP RENAME TO demo2;

   -- ο 휴지통 비우기
     -------------------------------------------------------
     --

     DROP TABLE test;
     DROP TABLE demo;
     DROP TABLE demo2;
    
    SELECT * FROM RECYCLEBIN;

    PURGE table demo;
    SELECT * FROM RECYCLEBIN;

    PURGE RECYCLEBIN;
    SELECT * FROM RECYCLEBIN;
    
    select * FROM tabs;

   -- ο TRUNCATE
     -------------------------------------------------------
     --테이블의 모든 레코드 삭제
     --ROLLBACK 불가. 자동 COMMIT됨
     
     select * from EMP2;

     TRUNCAte TABLE EMP2;
     -- 모든 레코드 삭제, 복구 불가, 자동 COMMIT

     select * from EMP2;

-------------------------------------------------------------
DROP TABLE EMP3;

SELECT * FROM TAB;

DROP TABLE EMP2 PURGE;
DROP TABLE "BIN$Diz7sasTTpKtXWQLNPcqPQ==$0" PURGE;

-----
-- ■ 데이터 조작언어(DML)
--데이터 처리(추가,수정,삭제 등)를 하는 언어
--자동 commit도지ㅣ 않으므로 트랜잭션을 처리해야함
--rollback 가능
--자바 등에서 insert,update,delete 명령을 실행하면 자동 commit됨
--자동 commit 유무 확인
SHOW AUTOCOMMIT;
 --on이면 자동으로 커밋됨 -> ROLLBACK 불가
 --of이면 자동으로 커밋 X -> commit 또는 rollback으로 트랜잭션 완료해야함 
--만약 on으로 나오는 경우 -> off로 변경
SET AUTOCOMMIT OFF;

-- 트랜잭션(Transaction)
    -- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업 단위
    -- A->B 천원 입급 - A천원빼기, B천원넣기 / 묶어서 트랜잭션
    -- DDL이나 DCL문장은 자동 COMMIT
    -- COMMIT; 
      --  트랜잭션이 완료(INSERT, UPDATE, DELETE 완료) - 데이터베이스에 저장 된다.
    -- ROLLBACK;
      --  트랜잭션이 취소(INSERT, UPDATE, DELETE 취소) - 데이터베이스에 저장 되지 않는다.

    

 -- ※ INSERT
   -- ο 단일 행 입력
     -------------------------------------------------------
     -- 기본형식
         INSERT INTO 테이블명 VALUES (값, 값);
         INSERT INTO 테이블명 (컬럼, 컬럼) VALUES (값, 값);

         --테이블 작성
         CREATE TABLE test1(
            num NUMBER PRIMARY KEY,
            name VARCHAR2(30) NOT NULL,
            birth DATE NOT NULL,
            memo VARCHAR2(1000)
         );
        
            INSERT INTO test1 VALUES(1,'홍길동','2000-10-10','테스트');
            INSERT INTO test1 VALUES(2,'김길동','2001-8-10');
            INSERT INTO test1 VALUES(2,'김길동','테스트','2001-08-10');

            --컬럼형 명시
            INSERT INTO test1 (NUM,NAME,BIRTH,MEMO)VALUES(2,'김길동','2001-08-10','테스트2');
            INSERT INTO test1 (NUM,NAME,BIRTH)VALUES(3,'이길동','2001-07-07');
            INSERT INTO test1(num,name,memo, birth)ValuEs(4,'하길동','메모','2002-06-10');
            
            SELECT * FROM test1;

            --트랜잭션 완료 : DB에 실제 저장
            COMMIT;
         

         -- 테이블의 모든 컬럼에 값 추가
         -- 모든 컬럼에 값을 추가하는 경우 컬럼명 생략 가능
         -- 컬럼명을 생략할 경우 반드시 테이블을 만들 때 컬럼의 순서대로 값을 입력해야함
         -- 날짜는 시스템 환경에 따라 문제를 발생시킬 수 있으므로 TO_DATE를 사용하여 날짜로 변경

    --추가 예
    INSERT INTO test1 (num,name,birth,memo) VALUES(5,'이자바','2002-08-10',");
    --"는 NULL

    SELECT * FROM test1;

    INSERT INTO test1 (num,name,birth) VALUES (5,'너자바','2001-07-07'); --에러 ORA-00001

    INSERT INTO test1 (num,name,birth) VALUES (6,'너자바','05/05/95'); --에러ORA-01847: 달의 날짜는 1에서 말일 사이어야 합니다

    INSERT INTO test1 (num,name,birth) VALUES(6,'너자바',TO_DATE('05/05/95','MM/DD/RR'));

    INSERT INTO test1 (num,name,birth,memo) VALUES(7,'이자바너자바다자바뭘자바',TO_DATE('05/05/95','MM/DD/RR'),'테스트');  
    --ORA-12899: "SKY"."TEST1"."NAME" 열에 대한 값이 너무 큼(실제: 36, 최대값: 30)

    INSERT INTO test1 (num,name,birth) VALUES(7,'이자바',SYSDATE);
    -- 시스템 날짜 등록
    
    COMMIT; -- 트랜잭션 완료(DB에 저장) / ROLLBACK;은 DB 저장 취소

    SELECT * FROM test1;

    --test1에 다음의 컬럼 추가
    -- created / TIMESTAMP
    ALTER TABLE test1 add created TIMESTAMP;

    --test1 테이블에 다음의 데이터 추가
    --num:8,name:마자바,birth:2000-07-08,created:202510161010123

    INSERT INTO test1 (num,name,birth,created) VALUES
    (8,'마자바',TO_DATE('2000-07-08','YYYY-MM-DD'),
        TO_TIMESTAMP('202510161010123','YYYYMMDDHH24MISSFF3'));
        commit;

        SELECT * FROM test1;

    --test2 테이블 작성
    -- hak 문자(30) PRIMARY KEY
    -- name 문자(30) NOT NULL
    -- kor 숫자(3) NOT NULL
    -- eng 숫자(3) NOT NULL
    -- mat 숫자(3) NOT NULL
    -- tot 숫자(3) 가상컬럼 kor+eng+mat
    -- ave 숫자(4,1) 가상컬럼 (kor+eng+mat)/3

    CREATE TABLE test2 (
    hak VARCHAR2(30) PRIMARY KEY,
    name VARCHAR2(30) NOT NULL,
    kor NUMBER(3) NOT NULL,
    eng NUMBER(3) NOT NULL,
    mat NUMBER(3) NOT NULL,
    tot NUMBER(3) GENERATED ALWAYS AS (kor + eng + mat) VIRTUAL,
    ave NUMBER(4,1) GENERATED ALWAYS AS ((kor + eng + mat) / 3) VIRTUAL
);

    --test2 테이블에 다음의 데이터 추가
    -- hak name kor eng mat
    -- 01 감자바 80  90  80
    -- 02 하자바 90  95  100

    INSERT INTO test2(hak,name,kor,eng,mat) VALUES('01','김자바',80,90,80);
    INSERT INTO test2(hak,name,kor,eng,mat) VALUES('02','하자바',90,95,100);

    -- 결과 확인
    commit;
    SELECT * FROM test2;

    
    INSERT INTO test2 VALUES('03','다자바',80,80,80); 
    --ORA-00947: 값의 수가 충분하지 않습니다

    INSERT INTO test2 VALUES('03','다자바',80,80,80,240,80); 
    --ORA-54013: INSERT 작업은 가상 열에서 허용되지 않습니다.
    


   -- ο subquery를 이용한 다중 행 입력
     -------------------------------------------------------
     -- 기본형식
          INSERT INTO 테이블명 [( 컬럼, 컬럼 )]  SELECT 문;


   -- ο unconditional INSERT ALL
     -------------------------------------------------------
     -- 기본형식
        INSERT ALL
              INTO 테이블명1 [( 컬럼, 컬럼 )] VALUES (수식1,수식2)
              INTO 테이블명2 [( 컬럼, 컬럼 )] VALUES (수식1,수식2)
              ...
         subquery;


   -- ο conditional INSERT {ALL | FIRST}
      -------------------------------------------------------
     -- 기본형식
        INSERT ALL
               WHEN 조건1 THEN
                   INTO 테이블명1 [( 컬럼, 컬럼 )] VALUES (수식1,수식2)
               WHEN 조건2 THEN
                   INTO 테이블명2 [( 컬럼, 컬럼 )] VALUES (수식1,수식2)
                  ...
               ELSE
                   INTO 테이블명n [( 컬럼, 컬럼 )] VALUES (수식1,수식2)
         subquery;


 -- ※ UPDATE
   -- ο UPDATE  : 데이터 수정
     -------------------------------------------------------
     -- 기본형식
       UPDATE 테이블명 SET 컬럼=값, 컬럼=값 WHERE 조건;
       UPDATE 테이블명 SET 컬럼=값, 컬럼=값;   -- 모든레코드 수정


 -- ※ DELETE
   -- ο DELETE : 데이터 삭제
     -------------------------------------------------------
     -- 기본형식
       DELETE FROM 테이블명 WHERE 조건;
       DELETE FROM 테이블명;  -- 모든레코드 삭제


 -- ※ MERGE
   -- ο MERGE : 데이터 병합
     -------------------------------------------------------
     -- 기본형식
       MERGE INTO 대상테이블명
           USING 비교할테이블 ON ( 조건 )
             WHEN MATCHED THEN
                 UPDATE SET 컬럼=값, 컬럼=값
            WHEN NOT MATCHED THEN
                INSERT [ (컬럼, 컬럼) ] VALUES (값, 값)
             ;








