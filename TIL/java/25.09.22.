25.09.22. MON

# RoundingMode.Down : 버림

c=a.divide(b,3,RoundingMode.DOWN);
a/b를 하고 소수점 3자리까지만 표기하고 나머지 버림

# 동일 객체 -> 동일 해쉬 코드 (해쉬코드가 같다고 동일한 객체는 아님) (값 기반이라 값 같으면 해쉬코드 같게 나옴)

# 문자열은 상수풀에 저장
-상수풀에 동일한 문자열이 존재하는 경우 문자열의 주소를 반환

#  문자열(StringClass) 불변
- 문자열 변경 -> 기존의 문자열이 변경되는 것이 아니라 새로운 메모리를 할당받아 처리
- 문자열 +시 성능 저하(사용x)
- wrapperclass도 불변

# System.out.println(문자열.length());
- 문자열 길이 구해서 출력

# 문자열 비교
System.out.println(s1==s2); //주소 비교 (사용x)
System.out.println(문자열.equals(문자열)); //값 비교

# 특정 위치 문자열 추출
s2=s1.substring(6,9);
인덱스 6-(9-1)까지 (6,7,8) 3개 추출

# 정규식
숫자 - \\d, 공백(엔터포함) - \\s, 

\\d:숫자, {n,m} : 최소 n자 최대 m자
p="\\d{1,3}";

# 문자열 길이
문자열.length

# 정수 문자열로 변환
Integer.toString(정수)

# switch case
- default 안 쓰면 컴파일 에러

# replaceAll()이 replace()보다 더욱 큰 범위의 함수같은데 이것만 사용하면 되지 않나?
-replace()보다 연산 속도가 느리다 / 정규표현식을 사용하지 않고 간단한 구문을 구현

# 문자열 비교
- 객체에서 ==는 주소 비교
System.out.println(s1==s2);
- 문자열 값 비교
String의 equals() 메소드 : object 클래스의 equals()를 재정의(override)하여 문자열 비교
System.out.println(s1.equals(s2));

# 문자열 추출 (a.substring(n,m)) 
- substring(s,e)  : s인덱스에서 e-1 인덱스까지 문자열 추출 (e-s)개
s2=s1.substring(6,9);
-인덱스 넘어서면 runtime error

# 특정 문자 추출 (a.charAt(n))
- char c= s1.charAt(인덱스);

# 문자열 비교 (a.equals(b))
- System.out.println(s1.equals("Seoul Korea"));

# 전체 대소문자 변환
- s.toLowerCase()
- s.toUpperCase()

# 포함
- s.indexOf("abc")==0 인덱스 0에 있으면 true

# 여러줄의 문자열 : """ ~ """

# StringBuilder : 가변적인 문자열 처리

# StringBuffer와 Stringbuilder의 equals는 주소 비교 (object의 equals)

#  StringBuffer와 Stringbuilder
	// 가변적인 문자열을 처리하는 경우 String보다 빠름
	// StringBuffer - 동시성을 지원. 다중 스레드 환경에서 안전
	// StringBuilder - 동시성 미지원. 다중 스레드 환경에서 위험. StringBuffer보다 빠름
	// 가변적인 문자열 처리가 아닌 경우 String 사용
	// 일반적으로 StringBuffer와 Stringbuilder는 마지막에 String으로 변환되어 사용됨

 - 동시성 문제 발생 - 버퍼, 아니면 - 빌더

 # a.append("") - 뒤에 추가
 # a.insert(0,"") - 앞에 추가

 # delete(s,e) : s인덱스부터 e-1인덱스까지 삭제

 
